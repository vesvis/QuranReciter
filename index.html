<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quran Reciter - Surah Sync</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Arabic Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Scheherazade+New:wght@400;700&family=Noto+Naskh+Arabic:wght@400;700&family=Cairo:wght@400;700&family=Lateef:wght@400;700&family=Rakkas&display=swap"
        rel="stylesheet">

    <style>
        body {
            background-color: #f3f4f6;
        }

        .quran-page {
            background-color: #fdfbf7;
            border: 1px solid #e5e7eb;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            direction: rtl;
            text-align: justify;
        }

        .quran-text {
            font-family: var(--quran-font, 'Amiri', serif);
            font-size: 2.2rem;
            line-height: 2.8;
            color: #1f2937;
        }

        .basmala {
            font-family: var(--quran-font, 'Amiri', serif);
            font-size: 3rem;
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid #e5e7eb;
            color: #16a34a;
            font-weight: 700;
            direction: rtl;
        }

        .ayah-span {
            padding: 0.2rem 0;
            border-radius: 0.2rem;
            transition: background-color 0.3s ease;
            cursor: pointer;
        }

        .active-ayah {
            background-color: #dcfce7;
            box-shadow: 0 0 0 4px #dcfce7;
        }

        .ayah-marker {
            font-family: 'Amiri', serif;
            color: #16a34a;
            font-size: 1.8rem;
            margin: 0 0.3rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            vertical-align: middle;
        }

        .ayah-number {
            font-size: 0.45em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            font-weight: bold;
            color: #000;
        }

        /* Floating Scroll Button */
        #scrollToCurrentBtn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #16a34a;
            color: white;
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }

        #scrollToCurrentBtn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #scrollToCurrentBtn:hover {
            transform: scale(1.1);
            background-color: #15803d;
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center p-6 overflow-y-auto">
    <div class="text-center mb-8">
        <h1 class="text-4xl font-bold text-gray-800 mb-2">Quran Reciter</h1>
        <p class="text-gray-600">Sync YouTube recitations with Quran text</p>
    </div>

    <div class="w-full max-w-2xl bg-white rounded-xl shadow-md p-6 mb-8">
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1">Recent Recitations</label>
            <select id="historySelect" onchange="loadFromHistory()"
                class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none">
                <option value="">Select a previous recitation...</option>
            </select>
        </div>

        <div class="flex flex-col md:flex-row gap-4 mb-4">
            <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 mb-1">YouTube URL</label>
                <input type="text" id="urlInput" placeholder="https://www.youtube.com/watch?v=..."
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none">
            </div>

            <div class="w-full md:w-48">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Style</label>
                <select id="fontSelect" onchange="changeFont()"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none bg-white">
                    <option value="'Amiri', serif">Amiri (Classic)</option>
                    <option value="'Scheherazade New', serif">Scheherazade (Traditional)</option>
                    <option value="'Noto Naskh Arabic', serif">Noto Naskh (Modern)</option>
                    <option value="'Lateef', serif">Lateef (Cursive)</option>
                    <option value="'Cairo', sans-serif">Cairo (Bold/Modern)</option>
                    <option value="'Rakkas', serif">Rakkas (Display)</option>
                </select>
            </div>

            <div class="flex items-end">
                <button onclick="startProcess()" id="processBtn"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition h-[50px]">
                    Process
                </button>
            </div>
        </div>
    </div>

    <div id="resultsArea" class="w-full max-w-4xl hidden">
        <div class="bg-white p-4 rounded-xl shadow-md mb-6 flex justify-center sticky top-4 z-10">
            <audio id="audioPlayer" controls class="w-full max-w-md"></audio>
        </div>

        <div class="text-center mb-6">
            <h2 id="surahTitle" class="text-3xl font-bold text-gray-800"></h2>
            <p id="surahDetails" class="text-gray-600"></p>
        </div>

        <div class="quran-page">
            <div id="quranContainer" class="quran-text"></div>
        </div>
    </div>

    <!-- Floating Scroll Button -->
    <button id="scrollToCurrentBtn" onclick="scrollToCurrent()" title="Go to current Ayah">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
    </button>

    <script>
        let currentTimeline = [];
        let audioPlayer = document.getElementById('audioPlayer');

        // --- IndexedDB Configuration ---
        const DB_NAME = 'QuranReciterDB';
        const DB_VERSION = 1;

        class LocalDB {
            static async open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('recitations')) {
                            const store = db.createObjectStore('recitations', { keyPath: 'id' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            static async saveRecitation(data, audioBlob) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readwrite');
                    const store = transaction.objectStore('recitations');
                    // Create a clean object to store
                    const item = {
                        id: data.id,
                        title: data.title,
                        surah_name: data.surah_name,
                        surah_number: data.surah_number || data.surah_id,
                        summary: data.summary,
                        segments: data.segments,
                        text: data.text,
                        surah_text: data.surah_text,
                        timeline: data.timeline,
                        audioBlob: audioBlob, // Store the binary blob
                        timestamp: Date.now()
                    };
                    const request = store.put(item);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            static async getAllRecitations() {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readonly');
                    const store = transaction.objectStore('recitations');
                    const index = store.index('timestamp');
                    const request = index.getAll();
                    request.onsuccess = () => resolve(request.result.reverse()); // Newest first
                    request.onerror = () => reject(request.error);
                });
            }

            static async getRecitation(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readonly');
                    const store = transaction.objectStore('recitations');
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        async function fetchSurahText(surahId) {
            try {
                const response = await fetch(`https://api.alquran.cloud/v1/surah/${surahId}/quran-uthmani`);
                if (!response.ok) return null;
                const data = await response.json();
                return data.data.ayahs.map(ayah => ({
                    surah: surahId,
                    ayah: ayah.numberInSurah,
                    text: ayah.text
                }));
            } catch (e) {
                console.error("[API] Failed to fetch Surah text:", e);
                return null;
            }
        }

        // --- Helper: Robust Arabic Normalization ---
        // Removes diacritics (Tashkeel) and unifies variations of Alif, Ya, etc.
        function normalizeArabic(text) {
            if (!text) return "";
            return text
                // Remove Tashkeel (all diacritics like Fatha, Kasra, Damma, Shadda, etc.)
                .replace(/[\u064B-\u065F\u0670]/g, "")
                // Normalize all forms of Alif (آ, إ, أ) to bare Alif (ا)
                .replace(/[آإأ]/g, "ا")
                // Normalize Ta-Marbuta (ة) to Ha (ه)
                .replace(/ة/g, "ه")
                // Normalize Alif Maqsura (ى) to Ya (ي)
                .replace(/ى/g, "ي")
                // Remove Tatweel (stretching character used in calligraphy)
                .replace(/\u0640/g, "")
                .trim();
        }

        // --- Helper: Levenshtein Distance ---
        function levenshtein(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            // Initialize first column
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            // Initialize first row
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            // Fill matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            matrix[i][j - 1] + 1,     // insertion
                            matrix[i - 1][j] + 1      // deletion
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        // --- Main Function: Build Timeline ---
        function buildTimeline(segments, surahText) {
            console.log("[TIMELINE] Building timeline from", segments.length, "segments and", surahText.length, "ayahs");

            if (!segments || !surahText) return [];

            const timeline = [];

            // Pre-normalize the Surah text once for performance
            const normalizedSurah = surahText.map(ayah => ({
                ...ayah,
                normalized: normalizeArabic(ayah.text)
            }));

            let matchCount = 0;

            // 1. STATE TRACKING: Keep track of where we are in the Surah.
            // We start at Ayah index 0. We will never search before this index.
            let currentAyahIndex = 0;

            // 2. WINDOW CONFIG: How many Ayahs ahead should we look?
            // 5 is usually safe to handle pauses or skipped segments.
            const LOOKAHEAD_WINDOW = 5;

            for (const segment of segments) {
                const heardText = segment.text || '';
                // Skip very short noise segments (less than 3 chars)
                if (heardText.trim().length < 3) continue;

                const normalizedSegment = normalizeArabic(heardText);

                // Variables to track the best match found within our specific WINDOW
                let bestMatch = null;
                let bestScore = 0; // Higher is better
                let bestMatchIndex = -1;

                // Constraint: Only search from currentAyahIndex up to (current + Window)
                // This ensures O(1) performance instead of O(N) per segment.
                const searchEnd = Math.min(currentAyahIndex + LOOKAHEAD_WINDOW, normalizedSurah.length);

                for (let i = currentAyahIndex; i < searchEnd; i++) {
                    const ayahNorm = normalizedSurah[i].normalized;

                    // Strategy A: Exact Containment (Fastest & Most Accurate)
                    if (ayahNorm.includes(normalizedSegment)) {
                        // Calculate score: Base 50 + Boost based on how much of the Ayah is covered
                        const score = (normalizedSegment.length / ayahNorm.length) * 100 + 50;
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = surahText[i];
                            bestMatchIndex = i;
                        }
                        // If we find an exact match inside this Ayah, we prefer it over fuzzy matches
                        continue;
                    }

                    // Strategy B: Fuzzy Match (Levenshtein)
                    // Optimization: Skip expensive calculation if lengths are wildly different
                    const lenDiff = Math.abs(normalizedSegment.length - ayahNorm.length);
                    if (lenDiff < Math.max(normalizedSegment.length, ayahNorm.length) * 0.6) {
                        const distance = levenshtein(normalizedSegment, ayahNorm);
                        const maxLength = Math.max(normalizedSegment.length, ayahNorm.length);
                        const similarity = ((maxLength - distance) / maxLength) * 100;

                        if (similarity > 60 && similarity > bestScore) {
                            bestScore = similarity;
                            bestMatch = surahText[i];
                            bestMatchIndex = i;
                        }
                    }

                    // Strategy C: Word Overlap (Backup for short segments or heavy noise)
                    if (normalizedSegment.length < ayahNorm.length * 0.5) {
                        const segWords = normalizedSegment.split(' ');
                        const ayahWords = ayahNorm.split(' ');
                        let wordMatches = 0;
                        for (const w of segWords) {
                            // Check words longer than 2 chars to avoid matching 'in', 'al', etc.
                            if (w.length > 2 && ayahWords.includes(w)) wordMatches++;
                        }
                        const wordScore = (wordMatches / segWords.length) * 100;

                        // Use a stricter threshold (75%) for this heuristic
                        if (wordScore > 75 && wordScore > bestScore) {
                            bestScore = wordScore;
                            bestMatch = surahText[i];
                            bestMatchIndex = i;
                        }
                    }
                }

                if (bestMatch) {
                    matchCount++;

                    // CRITICAL LOGIC: Update the tracker.
                    // If we matched Ayah 5, the next search will start at Ayah 5.
                    // It will NEVER search Ayah 1-4 again.
                    currentAyahIndex = bestMatchIndex;

                    timeline.push({
                        surah: bestMatch.surah,
                        ayah: bestMatch.ayah,
                        text: bestMatch.text,
                        start: segment.start || 0,
                        end: segment.end || 0
                    });
                }
            }

            console.log("[TIMELINE] Built timeline with", timeline.length, "entries (matched", matchCount, "segments)");

            // --- Merging Phase ---
            // Merge consecutive segments that belong to the same Ayah
            const merged = {};
            for (const entry of timeline) {
                const key = `${entry.surah}-${entry.ayah}`;
                if (!merged[key]) {
                    merged[key] = {
                        surah: entry.surah,
                        ayah: entry.ayah,
                        text: entry.text,
                        start: entry.start,
                        end: entry.end
                    };
                } else {
                    // Extend the range to include this new segment
                    merged[key].start = Math.min(merged[key].start, entry.start);
                    merged[key].end = Math.max(merged[key].end, entry.end);
                }
            }

            const mergedTimeline = Object.values(merged);
            mergedTimeline.sort((a, b) => a.start - b.start);
            console.log("[TIMELINE] After merging duplicates:", mergedTimeline.length, "unique ayahs");

            // --- Gap Filling Phase ---
            // Ensure highlighted regions flow smoothly into each other
            for (let i = 0; i < mergedTimeline.length - 1; i++) {
                // If there is a gap between this ayah and the next, bridge it
                // so the highlight doesn't disappear during the pause.
                if (mergedTimeline[i].end < mergedTimeline[i + 1].start) {
                    mergedTimeline[i].end = mergedTimeline[i + 1].start;
                }
            }

            // Add a small buffer to the final ayah so it doesn't cut off instantly
            if (mergedTimeline.length > 0) {
                mergedTimeline[mergedTimeline.length - 1].end += 1.5;
            }

            return mergedTimeline;
        }

        async function loadHistory() {
            const select = document.getElementById('historySelect');
            // Save current selection if any
            const currentSelection = select.value;

            select.innerHTML = '<option value="">Select a previous recitation...</option>';

            const map = new Map();

            // 1. Local IndexedDB (Highest Priority)
            try {
                const localItems = await LocalDB.getAllRecitations();
                if (localItems) {
                    localItems.forEach(item => map.set(item.id, { ...item, source: 'local' }));
                }
            } catch (e) { console.warn("[HISTORY] LocalDB error", e); }

            // 2. Server History
            try {
                const response = await fetch('/history');
                if (response.ok) {
                    const serverItems = await response.json();
                    serverItems.forEach(item => {
                        // Only add if not already present from local DB (prefer local because it has blob)
                        if (!map.has(item.id)) {
                            map.set(item.id, { ...item, source: 'server' });
                        }
                    });
                }
            } catch (e) { console.warn("[HISTORY] Server history error", e); }

            const allItems = Array.from(map.values()).sort((a, b) => b.timestamp - a.timestamp);

            if (allItems.length === 0) {
                console.log("[HISTORY] No recitations found.");
                return;
            }

            allItems.forEach(item => {
                const option = document.createElement('option');
                option.value = item.id;
                let label = item.surah_name;
                if (item.surah_number) label = `${item.surah_number}. ${label}`;
                if (item.title) label += ` - ${item.title}`;

                if (item.source === 'local') {
                    label += ' (Downloaded)';
                }
                option.textContent = label;
                select.appendChild(option);
            });

            // Restore selection if it still exists
            if (currentSelection && map.has(currentSelection)) {
                select.value = currentSelection;
            }
        }

        // Deprecated: Old localStorage method removed in favor of IndexedDB
        // function saveToHistory(data) { ... }

        async function loadFromHistory() {
            const select = document.getElementById('historySelect');
            const videoId = select.value;
            if (!videoId) return;

            // Update URL input for reference
            document.getElementById('urlInput').value = `https://www.youtube.com/watch?v=${videoId}`;

            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = true;
            processBtn.textContent = "Loading...";

            try {
                // 1. Try Local IndexedDB first (Best for offline)
                try {
                    const localData = await LocalDB.getRecitation(videoId);
                    if (localData && localData.audioBlob) {
                        console.log("[CACHE] Loaded from IndexedDB!");

                        // Create a Blob URL for the audio
                        localData.audio_url = URL.createObjectURL(localData.audioBlob);

                        initializePlayer(localData);
                        processBtn.disabled = false;
                        processBtn.textContent = "Process";
                        return;
                    }
                } catch (e) {
                    console.warn("[CACHE] IndexedDB lookup failed:", e);
                }

                // 2. Try Browser Cache / Service Worker (File based)
                let response = await fetch(`/cache/${videoId}.json`);

                if (response.ok) {
                    console.log("[CACHE] Loaded from browser cache/server!");
                    const data = await response.json();
                    data.id = videoId;
                    data.audio_url = `/cache/${videoId}.mp3`;

                    // If surah_text is missing, fetch it from the API
                    if (!data.surah_text || data.surah_text.length === 0) {
                        console.log("[CACHE] Surah text missing, fetching from API...");
                        const surahId = data.surah_id || data.surah_number;
                        if (surahId) {
                            data.surah_text = await fetchSurahText(surahId);
                            data.surah_number = surahId;
                        }
                    }

                    // If timeline is missing, build it
                    if ((!data.timeline || data.timeline.length === 0) && data.segments && data.surah_text) {
                        console.log("[CACHE] Building timeline from segments...");
                        data.timeline = buildTimeline(data.segments, data.surah_text);
                    }

                    // SAVE TO INDEXEDDB FOR NEXT TIME
                    // Fetch the audio as blob and save everything
                    fetch(`/cache/${videoId}.mp3`)
                        .then(r => r.blob())
                        .then(blob => {
                            console.log("[CACHE] Upgrading to IndexedDB...");
                            LocalDB.saveRecitation(data, blob).then(() => {
                                console.log("[CACHE] Upgraded successfully");
                                loadHistory(); // Update UI to show (Downloaded)
                            });
                        })
                        .catch(e => console.warn("Failed to upgrade to IDB", e));

                    initializePlayer(data);
                } else {
                    // 3. Fallback: Fetch from Server API (Dynamic)
                    console.log("[CACHE] Not in static cache, fetching from API...");
                    response = await fetch(`/recitation/${videoId}`);
                    if (!response.ok) throw new Error("Failed to load recitation from server");

                    const data = await response.json();
                    initializePlayer(data);

                    // Attempt to save to cache
                    if (data.id) {
                        fetch(`/cache/${data.id}.mp3`)
                            .then(r => r.blob())
                            .then(blob => LocalDB.saveRecitation(data, blob))
                            .then(loadHistory);
                    }
                }
            } catch (e) {
                console.error(e);
                alert("Failed to load recitation. The file may not exist.");
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "Process";
            }
        }

        async function startProcess() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) { alert("Please enter a YouTube URL"); return; }

            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = true;
            processBtn.textContent = "Processing...";

            try {
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url })
                });

                if (!response.ok) throw new Error((await response.json()).detail || "Processing failed");
                const data = await response.json();

                // Initialize player first so user sees progress
                initializePlayer(data);

                // Background: Save to IndexedDB
                if (data.id && data.audio_url) {
                    console.log("[CACHE] Downloading audio for offline storage...");
                    fetch(data.audio_url)
                        .then(response => {
                            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
                            return response.blob();
                        })
                        .then(blob => {
                            if (blob.size < 1000) throw new Error(`Blob too small (${blob.size} bytes), likely error page.`);
                            console.log(`[CACHE] Saving to IndexedDB (${(blob.size / 1024 / 1024).toFixed(2)} MB)...`);
                            return LocalDB.saveRecitation(data, blob);
                        })
                        .then(() => {
                            console.log("[CACHE] Saved offline successfully.");
                            loadHistory(); // Refresh dropdown to show 'Downloaded'
                        })
                        .catch(err => console.error("[CACHE] Failed to save offline:", err));
                } else {
                    console.warn("[CACHE] No audio URL to cache.");
                }
            } catch (e) {
                alert("Error: " + e.message);
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "Process";
            }
        }

        function initializePlayer(data) {
            console.log("Initializing Player with data:", data);
            if (!data.surah_text || data.surah_text.length === 0) {
                console.warn("[PLAYER] Surah text is empty, text display will be unavailable");
            }

            if (!data.timeline || data.timeline.length === 0) {
                console.warn("[PLAYER] Timeline is empty! Syncing will not work.");
            } else {
                console.log("[PLAYER] Timeline loaded with", data.timeline.length, "entries");
                console.log("[PLAYER] First timeline entry:", data.timeline[0]);
            }

            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('surahTitle').textContent = `Surah ${data.surah_name}`;
            document.getElementById('surahDetails').textContent = `Surah #${data.surah_number} • ${data.title}`;
            audioPlayer.src = data.audio_url;
            audioPlayer.load();
            currentTimeline = data.timeline;
            renderQuranText(data.surah_text);
        }

        function renderQuranText(surahText) {
            const container = document.getElementById('quranContainer');
            container.innerHTML = '';

            const basmalaText = 'بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ';
            const cleanBasmala = 'بسم الله الرحمن الرحيم';

            // Helper to remove diacritics for comparison
            const normalize = (text) => text.replace(/[\u064B-\u065F\u0670]/g, '').replace(/[ٱإأآ]/g, 'ا').replace(/ة/g, 'ه').replace(/ى/g, 'ي');

            // Always render Basmala for all Surahs except Tawbah (9)
            // We get surah number from the data object passed to initializePlayer, 
            // but here we only have surahText. 
            // We can infer it or just check the text content.

            // Let's check the first ayah
            const firstAyah = surahText[0];
            let startIndex = 0;

            if (firstAyah) {
                const normText = normalize(firstAyah.text);
                const normBasmala = normalize(basmalaText);

                // Check if first ayah contains Basmala
                if (normText.includes(cleanBasmala) || normText.includes(normBasmala)) {
                    // It's in the text, so we render the header and strip it from the ayah
                    const basmalaDiv = document.createElement('div');
                    basmalaDiv.className = 'basmala';
                    basmalaDiv.textContent = basmalaText;
                    container.appendChild(basmalaDiv);

                    // Remove Basmala from the text
                    // We try to remove the exact string first, then fallback to loose removal if needed
                    // But usually if it's there, it's at the start.

                    // Simple approach: If it starts with Basmala, slice it. 
                    // Since we don't know the exact diacritics in the text, this is tricky.
                    // But we can try to find the end of the Basmala in the text.

                    // For now, let's assume if we matched it, we want to show the header.
                    // And we try to strip it. If we can't strip it cleanly, we might duplicate it?
                    // No, let's try to strip based on length if normalized matches start.

                    let textToShow = firstAyah.text;
                    if (normText.startsWith(cleanBasmala) || normText.startsWith(normBasmala)) {
                        // It is at the start. 
                        // We need to remove the corresponding characters from the original text.
                        // This is hard because diacritics change length.

                        // Hack: Split by space and remove first 4 words? 
                        // Basmala is 4 words: Bism Allah Ar-Rahman Ar-Rahim
                        const words = firstAyah.text.split(' ');
                        if (words.length >= 4) {
                            // Reconstruct without first 4 words
                            textToShow = words.slice(4).join(' ');
                        }
                    }

                    if (textToShow.trim().length > 0) {
                        const span = document.createElement('span');
                        span.id = `ayah-${firstAyah.ayah}`;
                        span.className = 'ayah-span';
                        span.textContent = textToShow;
                        span.onclick = () => seekToAyah(firstAyah.ayah);

                        const marker = document.createElement('span');
                        marker.className = 'ayah-marker';
                        marker.innerHTML = `۝<span class="ayah-number">${firstAyah.ayah}</span>`;

                        container.appendChild(span);
                        container.appendChild(marker);
                        container.appendChild(document.createTextNode(' '));
                    }
                    startIndex = 1;
                } else {
                    // Basmala NOT in text. 
                    // We should still render the header if it's not Surah 9 (Tawbah).
                    // Since we don't have surah number here easily without changing function signature,
                    // let's assume we always want Basmala header unless it's Surah 1 (where it IS the first ayah).

                    // Actually, for Surah 1, Basmala IS Ayah 1. So it was caught above.
                    // For others, it's usually not in text.
                    // So we should add the header here.

                    // Exception: Surah 9.
                    // We can check if surahText[0].surah === 9
                    if (firstAyah.surah !== 9) {
                        const basmalaDiv = document.createElement('div');
                        basmalaDiv.className = 'basmala';
                        basmalaDiv.textContent = basmalaText;
                        container.appendChild(basmalaDiv);
                    }

                    // Render first ayah normally
                    startIndex = 0;
                }
            }

            for (let i = startIndex; i < surahText.length; i++) {
                const ayah = surahText[i];
                const span = document.createElement('span');
                span.id = `ayah-${ayah.ayah}`;
                span.className = 'ayah-span';
                span.textContent = ayah.text;
                span.onclick = () => seekToAyah(ayah.ayah);

                const marker = document.createElement('span');
                marker.className = 'ayah-marker';
                marker.innerHTML = `۝<span class="ayah-number">${ayah.ayah}</span>`;

                container.appendChild(span);
                container.appendChild(marker);
                container.appendChild(document.createTextNode(' '));
            }
        }


        function seekToAyah(ayahNumber) {
            const match = currentTimeline.find(t => t.ayah === ayahNumber);
            if (match) {
                audioPlayer.currentTime = match.start;
                audioPlayer.play();
            }
        }

        audioPlayer.ontimeupdate = () => {
            const time = audioPlayer.currentTime;
            const activeSegment = currentTimeline.find(t => time >= t.start && time <= t.end);

            // Debug log (throttled to every second roughly)
            if (Math.floor(time) % 5 === 0 && !audioPlayer.paused) {
                console.log(`[PLAYBACK] Time: ${time.toFixed(2)}s, Active Segment:`, activeSegment ? `Ayah ${activeSegment.ayah}` : "None");
            }

            document.querySelectorAll('.active-ayah').forEach(el => el.classList.remove('active-ayah'));

            const btn = document.getElementById('scrollToCurrentBtn');

            if (activeSegment) {
                const el = document.getElementById(`ayah-${activeSegment.ayah}`);
                if (el) {
                    el.classList.add('active-ayah');
                    // Show button if we have an active ayah
                    btn.classList.add('visible');
                } else {
                    console.warn(`[PLAYBACK] Active segment found for Ayah ${activeSegment.ayah}, but DOM element #ayah-${activeSegment.ayah} not found!`);
                }
            }
        };

        function scrollToCurrent() {
            const activeEl = document.querySelector('.active-ayah');
            if (activeEl) {
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function changeFont() {
            const font = document.getElementById('fontSelect').value;
            document.documentElement.style.setProperty('--quran-font', font);

            // Update classes
            const container = document.getElementById('quranContainer');
            container.style.fontFamily = font;

            // Adjust line height for some fonts
            if (font.includes('Cairo') || font.includes('Noto')) {
                container.style.lineHeight = '2.2';
            } else {
                container.style.lineHeight = '2.8';
            }
        }

        window.onload = () => {
            loadHistory();

            // Request Persistent Storage
            if (navigator.storage && navigator.storage.persist) {
                navigator.storage.persist().then(granted => {
                    console.log(granted ? "[STORAGE] Persistent storage granted" : "[STORAGE] Persistent storage NOT granted");
                });
            }

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(reg => console.log('Service Worker Registered', reg))
                    .catch(err => console.log('Service Worker Failed', err));
            }
        };
    </script>
</body>

</html>