<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quran Reciter - Surah Sync</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Arabic Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Scheherazade+New:wght@400;700&family=Noto+Naskh+Arabic:wght@400;700&family=Cairo:wght@400;700&family=Lateef:wght@400;700&family=Rakkas&display=swap"
        rel="stylesheet">

    <style>
        body {
            background-color: #f3f4f6;
        }

        .quran-page {
            background-color: #fdfbf7;
            border: 1px solid #e5e7eb;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            direction: rtl;
            text-align: justify;
        }

        .quran-text {
            font-family: var(--quran-font, 'Amiri', serif);
            font-size: 2.2rem;
            line-height: 2.8;
            color: #1f2937;
        }

        .basmala {
            font-family: var(--quran-font, 'Amiri', serif);
            font-size: 3rem;
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid #e5e7eb;
            color: #16a34a;
            font-weight: 700;
            direction: rtl;
        }

        .ayah-span {
            padding: 0.2rem 0;
            border-radius: 0.2rem;
            transition: background-color 0.3s ease;
            cursor: pointer;
        }

        .active-ayah {
            background-color: #dcfce7;
            box-shadow: 0 0 0 4px #dcfce7;
        }

        .ayah-marker {
            font-family: 'Amiri', serif;
            color: #16a34a;
            font-size: 1.8rem;
            margin: 0 0.3rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            vertical-align: middle;
        }

        .ayah-number {
            font-size: 0.45em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            font-weight: bold;
            color: #000;
        }

        /* Floating Scroll Button */
        #scrollToCurrentBtn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #16a34a;
            color: white;
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }

        #scrollToCurrentBtn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #scrollToCurrentBtn:hover {
            transform: scale(1.1);
            background-color: #15803d;
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center p-6 overflow-y-auto">
    <div class="text-center mb-8">
        <h1 class="text-4xl font-bold text-gray-800 mb-2">Quran Reciter</h1>
        <p class="text-gray-600">Sync YouTube recitations with Quran text</p>
    </div>

    <div class="w-full max-w-2xl bg-white rounded-xl shadow-md p-6 mb-8">
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1">Recent Recitations</label>
            <select id="historySelect" onchange="loadFromHistory()"
                class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none">
                <option value="">Select a previous recitation...</option>
            </select>
        </div>

        <div class="flex flex-col md:flex-row gap-4 mb-4">
            <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 mb-1">YouTube URL</label>
                <input type="text" id="urlInput" placeholder="https://www.youtube.com/watch?v=..."
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none">
            </div>

            <div class="w-full md:w-48">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Style</label>
                <select id="fontSelect" onchange="changeFont()"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:outline-none bg-white">
                    <option value="'Amiri', serif">Amiri (Classic)</option>
                    <option value="'Scheherazade New', serif">Scheherazade (Traditional)</option>
                    <option value="'Noto Naskh Arabic', serif">Noto Naskh (Modern)</option>
                    <option value="'Lateef', serif">Lateef (Cursive)</option>
                    <option value="'Cairo', sans-serif">Cairo (Bold/Modern)</option>
                    <option value="'Rakkas', serif">Rakkas (Display)</option>
                </select>
            </div>

            <div class="flex items-end">
                <button onclick="startProcess()" id="processBtn"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition h-[50px]">
                    Process
                </button>
            </div>
        </div>
    </div>

    <div id="resultsArea" class="w-full max-w-4xl hidden">
        <div class="bg-white p-4 rounded-xl shadow-md mb-6 flex justify-center sticky top-4 z-10">
            <audio id="audioPlayer" controls class="w-full max-w-md"></audio>
        </div>

        <div class="text-center mb-6">
            <h2 id="surahTitle" class="text-3xl font-bold text-gray-800"></h2>
            <p id="surahDetails" class="text-gray-600"></p>
        </div>

        <div class="quran-page">
            <div id="quranContainer" class="quran-text"></div>
        </div>
    </div>

    <!-- Floating Scroll Button -->
    <button id="scrollToCurrentBtn" onclick="scrollToCurrent()" title="Go to current Ayah">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
    </button>

    <script>
        let currentTimeline = [];
        let audioPlayer = document.getElementById('audioPlayer');

        async function fetchSurahText(surahId) {
            try {
                const response = await fetch(`https://api.alquran.cloud/v1/surah/${surahId}/quran-uthmani`);
                if (!response.ok) return null;
                const data = await response.json();
                return data.data.ayahs.map(ayah => ({
                    surah: surahId,
                    ayah: ayah.numberInSurah,
                    text: ayah.text
                }));
            } catch (e) {
                console.error("[API] Failed to fetch Surah text:", e);
                return null;
            }
        }

        function normalizeArabic(text) {
            // Remove diacritics and normalize characters
            return text
                .replace(/[\u064B-\u065F\u0670]/g, '') // Remove diacritics
                .replace(/[ٱإأآ]/g, 'ا')
                .replace(/ة/g, 'ه')
                .replace(/[ىي]/g, 'ي') // Normalize Ya/Alif Maqsura
                .replace(/ؤ/g, 'و')
                .replace(/ئ/g, 'ي')
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Levenshtein distance for fuzzy matching
        function levenshtein(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            Math.min(
                                matrix[i][j - 1] + 1, // insertion
                                matrix[i - 1][j] + 1 // deletion
                            )
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        function buildTimeline(segments, surahText) {
            console.log("[TIMELINE] Building timeline from", segments.length, "segments and", surahText.length, "ayahs");
            if (!segments || !surahText) return [];

            const timeline = [];
            const normalizedSurah = surahText.map(ayah => ({
                ...ayah,
                normalized: normalizeArabic(ayah.text)
            }));

            let matchCount = 0;

            for (const segment of segments) {
                const heardText = segment.text || '';
                if (heardText.trim().length < 5) continue;

                const normalized = normalizeArabic(heardText);

                // Find best match
                let bestMatch = null;
                let bestScore = 0; // Higher is better

                for (let i = 0; i < normalizedSurah.length; i++) {
                    const ayahNorm = normalizedSurah[i].normalized;

                    // 1. Exact containment (Best)
                    if (ayahNorm.includes(normalized)) {
                        const score = (normalized.length / ayahNorm.length) * 100 + 50; // Boosted
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = surahText[i];
                        }
                        continue;
                    }

                    // 2. Fuzzy Match (Levenshtein)
                    // Only check if lengths are somewhat similar to avoid expensive calc on totally wrong pairs
                    if (Math.abs(normalized.length - ayahNorm.length) < Math.max(normalized.length, ayahNorm.length) * 0.5) {
                        const distance = levenshtein(normalized, ayahNorm);
                        const maxLength = Math.max(normalized.length, ayahNorm.length);
                        const similarity = ((maxLength - distance) / maxLength) * 100;

                        if (similarity > 70 && similarity > bestScore) { // Threshold 70%
                            bestScore = similarity;
                            bestMatch = surahText[i];
                        }
                    }

                    // 3. Substring Fuzzy Match (for short segments in long ayahs)
                    // If segment is much shorter than ayah, check if it fuzzy matches ANY part of the ayah
                    // (Simplified: check word overlap)
                    if (normalized.length < ayahNorm.length * 0.5) {
                        const segWords = normalized.split(' ');
                        const ayahWords = ayahNorm.split(' ');
                        let wordMatches = 0;
                        for (const w of segWords) {
                            if (ayahWords.includes(w)) wordMatches++;
                        }
                        const wordScore = (wordMatches / segWords.length) * 100;
                        if (wordScore > 80 && wordScore > bestScore) { // High threshold for word overlap
                            bestScore = wordScore;
                            bestMatch = surahText[i];
                        }
                    }
                }

                if (bestMatch) {
                    matchCount++;
                    timeline.push({
                        surah: bestMatch.surah,
                        ayah: bestMatch.ayah,
                        text: bestMatch.text,
                        start: segment.start || 0,
                        end: segment.end || 0
                    });
                }
            }

            console.log("[TIMELINE] Built timeline with", timeline.length, "entries (matched", matchCount, "segments)");

            // CRITICAL FIX: Merge all segments that match the same ayah
            const merged = {};
            for (const entry of timeline) {
                const key = `${entry.surah}-${entry.ayah}`;
                if (!merged[key]) {
                    merged[key] = {
                        surah: entry.surah,
                        ayah: entry.ayah,
                        text: entry.text,
                        start: entry.start,
                        end: entry.end
                    };
                } else {
                    // Extend the range to include this segment
                    merged[key].start = Math.min(merged[key].start, entry.start);
                    merged[key].end = Math.max(merged[key].end, entry.end);
                }
            }

            const mergedTimeline = Object.values(merged);
            mergedTimeline.sort((a, b) => a.start - b.start);
            console.log("[TIMELINE] After merging duplicates:", mergedTimeline.length, "unique ayahs");

            // Fill gaps: Extend end time of each ayah to the start of the next
            for (let i = 0; i < mergedTimeline.length - 1; i++) {
                if (mergedTimeline[i].end < mergedTimeline[i + 1].start) {
                    mergedTimeline[i].end = mergedTimeline[i + 1].start;
                }
            }
            // Extend last segment slightly (e.g. 2 seconds) to ensure it stays highlighted
            if (mergedTimeline.length > 0) {
                mergedTimeline[mergedTimeline.length - 1].end += 2;
            }

            return mergedTimeline;
        }

        async function loadHistory() {
            const select = document.getElementById('historySelect');
            select.innerHTML = '<option value="">Select a previous recitation...</option>';

            try {
                // Open the audio-cache (where .json files are stored)
                const cache = await caches.open('audio-cache');
                const requests = await cache.keys();

                const history = [];

                // Find all .json files
                for (const request of requests) {
                    if (request.url.endsWith('.json')) {
                        try {
                            const response = await cache.match(request);
                            const data = await response.json();

                            // Extract video ID from URL (e.g., /cache/Kff-hAKbFmc.json)
                            const urlParts = request.url.split('/');
                            const filename = urlParts[urlParts.length - 1];
                            const videoId = filename.replace('.json', '');

                            history.push({
                                id: videoId,
                                surah_name: data.surah_name,
                                title: data.title
                            });
                        } catch (e) {
                            console.warn("[HISTORY] Failed to parse cached JSON:", request.url, e);
                        }
                    }
                }

                if (history.length === 0) {
                    console.log("[HISTORY] No cached recitations found");
                    return;
                }

                console.log("[HISTORY] Found", history.length, "cached recitations");

                // Sort alphabetically by Surah name
                history.sort((a, b) => a.surah_name.localeCompare(b.surah_name));

                history.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = `${item.surah_name} - ${item.title}`;
                    select.appendChild(option);
                });
            } catch (e) {
                console.error("[HISTORY] Failed to load from cache:", e);
            }
        }

        function saveToHistory(data) {
            // Get existing history
            const history = JSON.parse(localStorage.getItem('recitationHistory') || '[]');

            // Check if already exists
            const existingIndex = history.findIndex(item => item.id === data.id);

            const historyItem = {
                id: data.id,
                surah_name: data.surah_name,
                surah_number: data.surah_number || data.surah_id,
                title: data.title,
                timestamp: Date.now()
            };

            if (existingIndex >= 0) {
                // Update timestamp
                history[existingIndex] = historyItem;
            } else {
                // Add new
                history.push(historyItem);
            }

            // Keep only last 20
            if (history.length > 20) {
                history.sort((a, b) => b.timestamp - a.timestamp);
                history.splice(20);
            }

            localStorage.setItem('recitationHistory', JSON.stringify(history));
        }

        async function loadFromHistory() {
            const select = document.getElementById('historySelect');
            const videoId = select.value;
            if (!videoId) return;

            // Update URL input for reference
            document.getElementById('urlInput').value = `https://www.youtube.com/watch?v=${videoId}`;

            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = true;
            processBtn.textContent = "Loading...";

            try {
                // FIRST: Try to load from browser cache (via /cache/{id}.json)
                // The Service Worker will serve this from audio-cache if available
                let response = await fetch(`/cache/${videoId}.json`);

                if (response.ok) {
                    console.log("[CACHE] Loaded from browser cache!");
                    const data = await response.json();
                    // Add required fields that might be missing from old cache files
                    data.id = videoId;
                    data.audio_url = `/cache/${videoId}.mp3`;

                    // If surah_text is missing, fetch it from the API
                    if (!data.surah_text || data.surah_text.length === 0) {
                        console.log("[CACHE] Surah text missing, fetching from API...");
                        const surahId = data.surah_id || data.surah_number;
                        if (surahId) {
                            data.surah_text = await fetchSurahText(surahId);
                            data.surah_number = surahId;
                        }
                    }

                    // If timeline is missing, build it from segments
                    if ((!data.timeline || data.timeline.length === 0) && data.segments && data.surah_text) {
                        console.log("[CACHE] Building timeline from segments...");
                        data.timeline = buildTimeline(data.segments, data.surah_text);
                        console.log("[CACHE] Built timeline with", data.timeline.length, "entries");
                    }

                    initializePlayer(data);
                } else {
                    // FALLBACK: If not in browser cache, try server's /recitation endpoint
                    // This will fetch fresh data from server (and rebuild if needed)
                    console.log("[CACHE] Not in browser cache, fetching from server...");
                    response = await fetch(`/recitation/${videoId}`);

                    if (!response.ok) {
                        throw new Error("Failed to load recitation from server");
                    }

                    const data = await response.json();
                    initializePlayer(data);

                    // Cache the JSON file for next time
                    if (data.id) {
                        console.log("[CACHE] Caching files for:", data.id);
                        fetch(`https://quran-reciter.onrender.com/cache/${data.id}.json`)
                            .then(r => console.log("[CACHE] JSON cached:", r.status))
                            .catch(e => console.error("[CACHE] JSON cache failed", e));
                    }
                }
            } catch (e) {
                console.error(e);
                alert("Failed to load recitation. The file may not exist.");
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "Process";
            }
        }

        async function startProcess() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) { alert("Please enter a YouTube URL"); return; }

            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = true;
            processBtn.textContent = "Processing...";

            try {
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url })
                });

                if (!response.ok) throw new Error((await response.json()).detail || "Processing failed");
                const data = await response.json();
                saveToHistory(data);
                initializePlayer(data);
                loadHistory();

                // Background fetch to cache the transcription JSON
                if (data.id) {
                    console.log("[CACHE] Caching files for:", data.id);

                    // Fetch the .json file (triggers SW caching)
                    fetch(`https://quran-reciter.onrender.com/cache/${data.id}.json`)
                        .then(r => console.log("[CACHE] JSON cached:", r.status))
                        .catch(e => console.error("[CACHE] JSON cache failed", e));

                    // The .mp3 file will be cached when the audio player requests it
                } else {
                    console.warn("[CACHE] No ID in response, cannot cache!");
                }
            } catch (e) {
                alert("Error: " + e.message);
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "Process";
            }
        }

        function initializePlayer(data) {
            console.log("Initializing Player with data:", data);
            if (!data.surah_text || data.surah_text.length === 0) {
                console.warn("[PLAYER] Surah text is empty, text display will be unavailable");
            }

            if (!data.timeline || data.timeline.length === 0) {
                console.warn("[PLAYER] Timeline is empty! Syncing will not work.");
            } else {
                console.log("[PLAYER] Timeline loaded with", data.timeline.length, "entries");
                console.log("[PLAYER] First timeline entry:", data.timeline[0]);
            }

            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('surahTitle').textContent = `Surah ${data.surah_name}`;
            document.getElementById('surahDetails').textContent = `Surah #${data.surah_number} • ${data.title}`;
            audioPlayer.src = data.audio_url;
            audioPlayer.load();
            currentTimeline = data.timeline;
            renderQuranText(data.surah_text);
        }

        function renderQuranText(surahText) {
            const container = document.getElementById('quranContainer');
            container.innerHTML = '';

            const basmalaText = 'بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ';
            const cleanBasmala = 'بسم الله الرحمن الرحيم';

            // Helper to remove diacritics for comparison
            const normalize = (text) => text.replace(/[\u064B-\u065F\u0670]/g, '').replace(/[ٱإأآ]/g, 'ا').replace(/ة/g, 'ه').replace(/ى/g, 'ي');

            // Always render Basmala for all Surahs except Tawbah (9)
            // We get surah number from the data object passed to initializePlayer, 
            // but here we only have surahText. 
            // We can infer it or just check the text content.

            // Let's check the first ayah
            const firstAyah = surahText[0];
            let startIndex = 0;

            if (firstAyah) {
                const normText = normalize(firstAyah.text);
                const normBasmala = normalize(basmalaText);

                // Check if first ayah contains Basmala
                if (normText.includes(cleanBasmala) || normText.includes(normBasmala)) {
                    // It's in the text, so we render the header and strip it from the ayah
                    const basmalaDiv = document.createElement('div');
                    basmalaDiv.className = 'basmala';
                    basmalaDiv.textContent = basmalaText;
                    container.appendChild(basmalaDiv);

                    // Remove Basmala from the text
                    // We try to remove the exact string first, then fallback to loose removal if needed
                    // But usually if it's there, it's at the start.

                    // Simple approach: If it starts with Basmala, slice it. 
                    // Since we don't know the exact diacritics in the text, this is tricky.
                    // But we can try to find the end of the Basmala in the text.

                    // For now, let's assume if we matched it, we want to show the header.
                    // And we try to strip it. If we can't strip it cleanly, we might duplicate it?
                    // No, let's try to strip based on length if normalized matches start.

                    let textToShow = firstAyah.text;
                    if (normText.startsWith(cleanBasmala) || normText.startsWith(normBasmala)) {
                        // It is at the start. 
                        // We need to remove the corresponding characters from the original text.
                        // This is hard because diacritics change length.

                        // Hack: Split by space and remove first 4 words? 
                        // Basmala is 4 words: Bism Allah Ar-Rahman Ar-Rahim
                        const words = firstAyah.text.split(' ');
                        if (words.length >= 4) {
                            // Reconstruct without first 4 words
                            textToShow = words.slice(4).join(' ');
                        }
                    }

                    if (textToShow.trim().length > 0) {
                        const span = document.createElement('span');
                        span.id = `ayah-${firstAyah.ayah}`;
                        span.className = 'ayah-span';
                        span.textContent = textToShow;
                        span.onclick = () => seekToAyah(firstAyah.ayah);

                        const marker = document.createElement('span');
                        marker.className = 'ayah-marker';
                        marker.innerHTML = `۝<span class="ayah-number">${firstAyah.ayah}</span>`;

                        container.appendChild(span);
                        container.appendChild(marker);
                        container.appendChild(document.createTextNode(' '));
                    }
                    startIndex = 1;
                } else {
                    // Basmala NOT in text. 
                    // We should still render the header if it's not Surah 9 (Tawbah).
                    // Since we don't have surah number here easily without changing function signature,
                    // let's assume we always want Basmala header unless it's Surah 1 (where it IS the first ayah).

                    // Actually, for Surah 1, Basmala IS Ayah 1. So it was caught above.
                    // For others, it's usually not in text.
                    // So we should add the header here.

                    // Exception: Surah 9.
                    // We can check if surahText[0].surah === 9
                    if (firstAyah.surah !== 9) {
                        const basmalaDiv = document.createElement('div');
                        basmalaDiv.className = 'basmala';
                        basmalaDiv.textContent = basmalaText;
                        container.appendChild(basmalaDiv);
                    }

                    // Render first ayah normally
                    startIndex = 0;
                }
            }

            for (let i = startIndex; i < surahText.length; i++) {
                const ayah = surahText[i];
                const span = document.createElement('span');
                span.id = `ayah-${ayah.ayah}`;
                span.className = 'ayah-span';
                span.textContent = ayah.text;
                span.onclick = () => seekToAyah(ayah.ayah);

                const marker = document.createElement('span');
                marker.className = 'ayah-marker';
                marker.innerHTML = `۝<span class="ayah-number">${ayah.ayah}</span>`;

                container.appendChild(span);
                container.appendChild(marker);
                container.appendChild(document.createTextNode(' '));
            }
        }


        function seekToAyah(ayahNumber) {
            const match = currentTimeline.find(t => t.ayah === ayahNumber);
            if (match) {
                audioPlayer.currentTime = match.start;
                audioPlayer.play();
            }
        }

        audioPlayer.ontimeupdate = () => {
            const time = audioPlayer.currentTime;
            const activeSegment = currentTimeline.find(t => time >= t.start && time <= t.end);

            // Debug log (throttled to every second roughly)
            if (Math.floor(time) % 5 === 0 && !audioPlayer.paused) {
                console.log(`[PLAYBACK] Time: ${time.toFixed(2)}s, Active Segment:`, activeSegment ? `Ayah ${activeSegment.ayah}` : "None");
            }

            document.querySelectorAll('.active-ayah').forEach(el => el.classList.remove('active-ayah'));

            const btn = document.getElementById('scrollToCurrentBtn');

            if (activeSegment) {
                const el = document.getElementById(`ayah-${activeSegment.ayah}`);
                if (el) {
                    el.classList.add('active-ayah');
                    // Show button if we have an active ayah
                    btn.classList.add('visible');
                } else {
                    console.warn(`[PLAYBACK] Active segment found for Ayah ${activeSegment.ayah}, but DOM element #ayah-${activeSegment.ayah} not found!`);
                }
            }
        };

        function scrollToCurrent() {
            const activeEl = document.querySelector('.active-ayah');
            if (activeEl) {
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function changeFont() {
            const font = document.getElementById('fontSelect').value;
            document.documentElement.style.setProperty('--quran-font', font);

            // Update classes
            const container = document.getElementById('quranContainer');
            container.style.fontFamily = font;

            // Adjust line height for some fonts
            if (font.includes('Cairo') || font.includes('Noto')) {
                container.style.lineHeight = '2.2';
            } else {
                container.style.lineHeight = '2.8';
            }
        }

        window.onload = () => {
            loadHistory();
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(reg => console.log('Service Worker Registered', reg))
                    .catch(err => console.log('Service Worker Failed', err));
            }
        };
    </script>
</body>

</html>