<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quran Reciter - Surah Sync</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Arabic Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Scheherazade+New:wght@400;700&family=Noto+Naskh+Arabic:wght@400;700&family=Cairo:wght@400;700&family=Lateef:wght@400;700&family=Rakkas&display=swap"
        rel="stylesheet">

    <style>
        html,
        body {
            overflow-x: hidden;
            width: 100%;
            margin: 0;
            padding: 0;
        }

        /* Custom Scrollbar for Webkit */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* Animations */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in-down {
            animation: fadeInDown 0.8s ease-out;
        }

        .animate-fade-in-up {
            animation: fadeInUp 0.8s ease-out;
        }

        .animate-check-bounce {
            animation: checkBounce 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes checkBounce {
            0% {
                transform: scale(0.9);
                opacity: 0;
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .quran-page {
            /* Creamy paper background */
            background-color: #fdfbf7;
            border-radius: 1rem;
            direction: rtl;
            text-align: justify;
            /* Subtle texture overlay */
            background-image: linear-gradient(to bottom, #ffffff, #fdfbf7 10%, #fdfbf7);
        }

        .quran-text {
            font-family: var(--quran-font, 'Amiri', serif);
            /* Responsive Font Size using Clamp */
            font-size: var(--quran-font-size, clamp(1.8rem, 5vw, 2.4rem));
            line-height: 2.5;
            color: #1f2937;
        }

        .basmala {
            font-family: var(--quran-font, 'Amiri', serif);
            font-size: var(--quran-font-size, clamp(1.8rem, 5vw, 2.4rem));
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            color: #059669;
            /* Emerald 600 */
            font-weight: 700;
            direction: rtl;
            position: relative;
        }

        .basmala::after {
            content: "€û";
            display: block;
            margin-top: 0.5rem;
            font-size: 1.5rem;
            color: #d1d5db;
        }

        .ayah-span {
            padding: 0.25rem 0.1rem;
            border-radius: 0.3rem;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
        }

        .ayah-span:hover {
            background-color: rgba(16, 185, 129, 0.1);
            /* Emerald 500 at 10% */
        }

        .active-ayah {
            background-color: rgba(16, 185, 129, 0.25);
            box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.4);
        }

        .ayah-marker {
            font-family: 'Amiri', serif;
            color: #059669;
            font-size: 0.9em;
            margin: 0 0.4rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            vertical-align: middle;
            user-select: none;
        }

        .ayah-number {
            font-size: 0.4em;
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 900;
            color: #064e3b;
            /* Emerald 900 */
            font-family: sans-serif;
        }

        #scrollToCurrentBtn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Custom scrollbar for settings */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
    </style>
</head>

<body
    class="bg-gradient-to-br from-[#0f172a] via-[#1e293b] to-[#0f172a] min-h-screen text-gray-800 font-sans selection:bg-emerald-500 selection:text-white pb-20 overflow-x-hidden">

    <!-- Background Pattern DO NOT REMOVE -->
    <div class="fixed inset-0 z-0 opacity-20 pointer-events-none"
        style="background-image: url('https://www.transparenttextures.com/patterns/arabesque.png');">
    </div>

    <!-- Main Content -->
    <div class="relative z-10 w-full max-w-5xl mx-auto px-4 py-8 md:py-12 flex flex-col items-center">

        <!-- Header -->
        <div class="text-center mb-10 animate-fade-in-down">
            <h1
                class="text-4xl md:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-cyan-500 mb-4 drop-shadow-sm">
                Quran Reciter
            </h1>
            <p class="text-slate-400 text-lg md:text-xl font-light tracking-wide">
                Sync YouTube recitations with the Holy Quran
            </p>
        </div>

        <!-- Controls Card -->
        <div
            class="w-full bg-white/10 backdrop-blur-lg border border-white/20 rounded-3xl shadow-2xl p-5 md:p-8 mb-10 transition-all hover:bg-white/15">

            <!-- Mode Tabs -->
            <div class="flex space-x-4 mb-6 border-b border-gray-600/30 pb-4">
                <button id="tab-youtube" onclick="switchMode('youtube')"
                    class="text-emerald-400 font-bold border-b-2 border-emerald-400 pb-1 text-lg transition-colors">
                    YouTube Sync
                </button>
                <button id="tab-read" onclick="switchMode('read')"
                    class="text-slate-400 hover:text-emerald-300 font-medium pb-1 text-lg transition-colors border-b-2 border-transparent">
                    Read Mode
                </button>
            </div>

            <!-- YouTube Mode Controls -->
            <div id="controls-youtube" class="block animate-fade-in-down">
                <!-- History Dropdown -->
                <div class="mb-6">
                    <label class="block text-emerald-400 text-sm font-bold uppercase tracking-wider mb-2">Recent
                        Recitations</label>
                    <div class="relative">
                        <select id="historySelect" onchange="loadFromHistory()"
                            class="block w-full appearance-none bg-slate-800/50 border border-slate-600 text-slate-200 py-3 px-4 pr-8 rounded-xl leading-tight focus:outline-none focus:bg-slate-800 focus:border-emerald-500 transition-colors cursor-pointer">
                            <option value="">Select a previous recitation...</option>
                        </select>
                        <div
                            class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-400">
                            <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" />
                            </svg>
                        </div>
                    </div>
                </div>

                <!-- Input & Actions -->
                <div class="flex flex-col md:flex-row gap-4">
                    <div class="flex-1">
                        <label class="block text-emerald-400 text-sm font-bold uppercase tracking-wider mb-2">YouTube
                            URL</label>
                        <input type="text" id="urlInput" placeholder="Paste YouTube link here..."
                            class="w-full bg-slate-800/50 border border-slate-600 text-white placeholder-slate-500 p-4 rounded-xl focus:ring-2 focus:ring-emerald-500 focus:border-transparent outline-none transition-all shadow-inner">
                    </div>

                    <div class="flex gap-3 items-end">
                        <button onclick="openSettings()"
                            class="group p-4 bg-slate-700/50 hover:bg-slate-700 text-emerald-400 rounded-xl border border-slate-600 transition-all active:scale-95 flex items-center justify-center h-[58px] w-[58px]"
                            title="Settings">
                            <svg xmlns="http://www.w3.org/2000/svg"
                                class="h-6 w-6 group-hover:rotate-90 transition-transform duration-500" fill="none"
                                viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                        </button>
                        <button onclick="startProcess()" id="processBtn"
                            class="flex-1 md:flex-none bg-gradient-to-r from-emerald-600 to-green-600 hover:from-emerald-500 hover:to-green-500 text-white font-bold py-4 px-8 rounded-xl shadow-lg shadow-emerald-900/20 transform transition-all active:scale-95 h-[58px] min-w-[120px] flex items-center justify-center">
                            Process
                        </button>
                    </div>
                </div>
            </div>

            <!-- Read Mode Controls (Hidden by default) -->
            <div id="controls-read" class="hidden animate-fade-in-down">
                <label class="block text-emerald-400 text-sm font-bold uppercase tracking-wider mb-2">Select
                    Surah</label>
                <div class="flex gap-4">
                    <div class="relative flex-1">
                        <select id="surahSelect" onchange="loadSelectedSurah()"
                            class="block w-full appearance-none bg-slate-800/50 border border-slate-600 text-slate-200 py-3 px-4 pr-8 rounded-xl leading-tight focus:outline-none focus:bg-slate-800 focus:border-emerald-500 transition-colors cursor-pointer">
                            <option value="">Choose a Surah...</option>
                            <!-- Populated by JS -->
                        </select>
                        <div
                            class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-400">
                            <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" />
                            </svg>
                        </div>
                    </div>

                    <button onclick="openSettings()"
                        class="group p-4 bg-slate-700/50 hover:bg-slate-700 text-emerald-400 rounded-xl border border-slate-600 transition-all active:scale-95 flex items-center justify-center h-[52px] w-[58px]"
                        title="Settings">
                        <svg xmlns="http://www.w3.org/2000/svg"
                            class="h-6 w-6 group-hover:rotate-90 transition-transform duration-500" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Results Area -->
        <div id="resultsArea" class="w-full hidden animate-fade-in-up">

            <!-- Sentinel for scroll detection -->
            <div id="sticky-sentinel" class="w-full h-px opacity-0 absolute -mt-4"></div>

            <!-- Placeholder (occupies space when player is fixed) -->
            <div id="sticky-placeholder" class="hidden h-24 mb-8 w-full"></div>

            <!-- Player Container -->
            <div id="sticky-player" class="z-40 w-full mb-8 px-2 transition-transform duration-300 origin-top">
                <div class="max-w-5xl mx-auto">
                    <div
                        class="bg-slate-800/90 backdrop-blur-md p-4 rounded-2xl shadow-xl border border-slate-700/50 flex flex-col justify-center">
                        <audio id="audioPlayer" controls class="w-full h-10 outline-none mb-2"></audio>

                        <!-- Simple Repeat Control -->
                        <div class="flex justify-end">
                            <button id="btn-loop-surah" onclick="toggleSurahLoop()"
                                class="text-xs px-3 py-1.5 rounded-lg transition-all flex items-center gap-1.5 border border-slate-600 bg-slate-700/50 text-slate-400 hover:bg-slate-700 hover:text-white">
                                <span class="text-sm">üîÅ</span> <span>Loop Surah</span>
                            </button>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Title Info -->
            <div class="text-center mb-8">
                <h2 id="surahTitle" class="text-4xl md:text-5xl font-amiri text-emerald-100 mb-2 drop-shadow-md"></h2>
                <p id="surahDetails" class="text-slate-400 text-lg"></p>
            </div>

            <!-- Quran Text Display -->
            <div class="quran-page bg-[#fdfbf7] text-slate-800 shadow-2xl relative overflow-hidden">
                <!-- Decorative Frame Removed -->

                <div id="quranContainer" class="quran-text relative z-10 p-2 md:p-4"></div>
            </div>
        </div>
    </div>

    <!-- Floating Scroll Button -->
    <button id="scrollToCurrentBtn" onclick="scrollToCurrent()"
        class="fixed bottom-6 right-6 bg-emerald-600 hover:bg-emerald-500 text-white p-4 rounded-full shadow-lg shadow-emerald-900/30 transform transition-all hover:scale-110 opacity-0 pointer-events-none z-50 flex items-center justify-center"
        title="Go to current Ayah">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
    </button>

    <!-- Update Toast -->
    <div id="updateToast"
        class="fixed bottom-6 left-6 z-50 transform translate-y-20 opacity-0 transition-all duration-500 ease-out hidden">
        <div
            class="bg-slate-800/95 backdrop-blur-md border border-slate-700 text-white rounded-xl shadow-2xl p-4 flex items-center gap-4 max-w-sm">
            <div class="bg-emerald-500/20 p-2 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-emerald-400" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </div>
            <div>
                <h4 class="font-bold text-sm text-emerald-100">Update Available</h4>
                <p class="text-xs text-slate-400">A new version is ready.</p>
            </div>
            <button onclick="window.location.reload()"
                class="ml-2 bg-emerald-600 hover:bg-emerald-500 text-white text-xs font-bold py-2 px-4 rounded-lg transition-colors">
                Refresh
            </button>
            <button onclick="dismissToast()" class="text-slate-500 hover:text-white transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal"
        class="fixed inset-0 bg-slate-900/80 backdrop-blur-sm hidden z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-lg max-h-[85vh] overflow-y-auto animate-check-bounce">
            <div class="p-6 border-b border-gray-100 flex justify-between items-center bg-gray-50/50">
                <h3 class="text-2xl font-bold text-gray-800">Settings</h3>
                <button onclick="closeSettings()"
                    class="p-2 hover:bg-gray-200 rounded-full transition-colors text-gray-500">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <div class="p-6 space-y-8">
                <!-- Font Settings -->
                <div>
                    <h4 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-4">Reading Experience</h4>

                    <div class="mb-5">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Font Style</label>
                        <div class="relative">
                            <select id="fontSelect" onchange="changeFont()"
                                class="w-full appearance-none p-3 bg-gray-50 border border-gray-200 rounded-xl focus:ring-2 focus:ring-emerald-500 outline-none text-gray-700 text-lg">
                                <option value="'Amiri', serif">Amiri (Classic)</option>
                                <option value="'Scheherazade New', serif">Scheherazade (Traditional)</option>
                                <option value="'Noto Naskh Arabic', serif">Noto Naskh (Modern)</option>
                                <option value="'Lateef', serif">Lateef (Cursive)</option>
                                <option value="'Cairo', sans-serif">Cairo (Bold)</option>
                                <option value="'Rakkas', serif">Rakkas (Display)</option>
                            </select>
                            <div
                                class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-gray-500">
                                <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 20 20">
                                    <path
                                        d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" />
                                </svg>
                            </div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium text-gray-700">Font Size</label>
                            <span id="fontSizeValue"
                                class="text-sm font-bold text-emerald-600 bg-emerald-50 px-2 py-0.5 rounded">2.2rem</span>
                        </div>
                        <input type="range" id="fontSizeSlider" min="1.0" max="5.0" step="0.1" value="2.2"
                            oninput="changeFontSize()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-emerald-600">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>Small</span>
                            <span>Large</span>
                        </div>
                    </div>
                </div>

                <hr class="border-gray-100">

                <!-- Download Management -->
                <div>
                    <h4 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-4">Saved Recitations</h4>
                    <div id="downloadsList" class="space-y-3 max-h-48 overflow-y-auto pr-2 custom-scrollbar">
                        <p class="text-gray-400 text-sm text-center py-6 italic">Loading downloads...</p>
                    </div>
                </div>
            </div>

            <div class="p-6 bg-gray-50 rounded-b-2xl border-t border-gray-100 flex justify-end">
                <button onclick="closeSettings()"
                    class="bg-slate-800 hover:bg-slate-900 text-white font-bold py-3 px-8 rounded-xl transition-all shadow-lg shadow-slate-300">
                    Done
                </button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = ""; // Use relative paths for same-origin API calls
        let currentTimeline = [];
        let audioPlayer = document.getElementById('audioPlayer');

        // --- Auto-Scroll Logic ---
        let isUserInteracting = false;
        let inactivityTimer = null;
        const INACTIVITY_DELAY = 4000; // 4 seconds

        // --- Repeat Logic State ---
        let loopSurah = false; // New state for surah looping

        function toggleSurahLoop() {
            loopSurah = !loopSurah;
            const btn = document.getElementById('btn-loop-surah');
            if (loopSurah) {
                btn.classList.remove('bg-slate-700/50', 'text-slate-400', 'border-slate-600', 'hover:bg-slate-700', 'hover:text-white');
                btn.classList.add('bg-emerald-600', 'text-white', 'border-emerald-500', 'hover:bg-emerald-500');
            } else {
                btn.classList.remove('bg-emerald-600', 'text-white', 'border-emerald-500', 'hover:bg-emerald-500');
                btn.classList.add('bg-slate-700/50', 'text-slate-400', 'border-slate-600', 'hover:bg-slate-700', 'hover:text-white');
            }
        }

        function resetInactivity() {
            isUserInteracting = true;
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(() => {
                isUserInteracting = false;
                // Optional: Trigger an immediate catch-up scroll when timer expires
                scrollToActiveAyah();
            }, INACTIVITY_DELAY);
        }

        // Listen for user interaction to pause auto-scroll
        ['mousemove', 'mousedown', 'touchstart', 'scroll', 'keydown', 'click'].forEach(evt =>
            window.addEventListener(evt, resetInactivity, { passive: true })
        );

        // Helper to scroll to the active element
        function scrollToActiveAyah() {
            const activeEl = document.querySelector('.active-ayah');
            if (activeEl) {
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // --- Sticky Player Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const sentinel = document.getElementById('sticky-sentinel');
            const player = document.getElementById('sticky-player');
            const placeholder = document.getElementById('sticky-placeholder');

            const observer = new IntersectionObserver((entries) => {
                if (entries[0].boundingClientRect.top < 0 && !entries[0].isIntersecting) {
                    // Scrolled past -> Make Sticky
                    player.classList.add('fixed', 'top-0', 'left-0', 'right-0', 'pt-2');
                    player.classList.remove('mb-8', 'px-2'); // Remove margins/padding that fight with fixed
                    // Add padding to inner wrapper if needed, or rely on the container constraints
                    placeholder.classList.remove('hidden');
                } else {
                    // Back in view -> Make Static
                    player.classList.remove('fixed', 'top-0', 'left-0', 'right-0', 'pt-2');
                    player.classList.add('mb-8', 'px-2');
                    placeholder.classList.add('hidden');
                }
            }, { threshold: 0 });

            if (sentinel) observer.observe(sentinel);

            // Start inactivity timer on load
            resetInactivity();
        });

        // --- IndexedDB Configuration ---
        const DB_NAME = 'QuranReciterDB';
        const DB_VERSION = 1;

        class LocalDB {
            static async open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('recitations')) {
                            const store = db.createObjectStore('recitations', { keyPath: 'id' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            static async saveRecitation(data, audioBlob) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readwrite');
                    const store = transaction.objectStore('recitations');
                    // Create a clean object to store
                    const item = {
                        id: data.id,
                        title: data.title,
                        surah_name: data.surah_name,
                        surah_number: data.surah_number || data.surah_id,
                        summary: data.summary,
                        segments: data.segments,
                        text: data.text,
                        surah_text: data.surah_text,
                        timeline: data.timeline,
                        audioBlob: audioBlob, // Store the binary blob
                        timestamp: Date.now()
                    };
                    const request = store.put(item);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            static async getAllRecitations() {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readonly');
                    const store = transaction.objectStore('recitations');
                    const index = store.index('timestamp');
                    const request = index.getAll();
                    request.onsuccess = () => resolve(request.result.reverse()); // Newest first
                    request.onerror = () => reject(request.error);
                });
            }

            static async getRecitation(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readonly');
                    const store = transaction.objectStore('recitations');
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            static async deleteRecitation(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['recitations'], 'readwrite');
                    const store = transaction.objectStore('recitations');
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        }

        async function fetchSurahText(surahId) {
            try {
                const response = await fetch(`https://api.alquran.cloud/v1/surah/${surahId}/quran-uthmani`);
                if (!response.ok) return null;
                const data = await response.json();
                return data.data.ayahs.map(ayah => ({
                    surah: surahId,
                    ayah: ayah.numberInSurah,
                    text: ayah.text
                }));
            } catch (e) {
                console.error("[API] Failed to fetch Surah text:", e);
                return null;
            }
        }

        // --- Helper: Robust Arabic Normalization ---
        // Removes diacritics (Tashkeel) and unifies variations of Alif, Ya, etc.
        function normalizeArabic(text) {
            if (!text) return "";
            return text
                // Remove Tashkeel (all diacritics like Fatha, Kasra, Damma, Shadda, etc.)
                .replace(/[\u064B-\u065F\u0670]/g, "")
                // Normalize all forms of Alif (ÿ¢, ÿ•, ÿ£) to bare Alif (ÿß)
                .replace(/[ÿ¢ÿ•ÿ£]/g, "ÿß")
                // Normalize Ta-Marbuta (ÿ©) to Ha (Ÿá)
                .replace(/ÿ©/g, "Ÿá")
                // Normalize Alif Maqsura (Ÿâ) to Ya (Ÿä)
                .replace(/Ÿâ/g, "Ÿä")
                // Remove Tatweel (stretching character used in calligraphy)
                .replace(/\u0640/g, "")
                .trim();
        }

        // --- Helper: Levenshtein Distance ---
        function levenshtein(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];

            // Initialize first column
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            // Initialize first row
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            // Fill matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            matrix[i][j - 1] + 1,     // insertion
                            matrix[i - 1][j] + 1      // deletion
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        // --- Main Function: Build Timeline ---
        function buildTimeline(segments, surahText) {
            console.log("[TIMELINE] Building timeline from", segments.length, "segments and", surahText.length, "ayahs");

            if (!segments || !surahText) return [];

            const timeline = [];

            // Pre-normalize the Surah text once for performance
            const normalizedSurah = surahText.map(ayah => ({
                ...ayah,
                normalized: normalizeArabic(ayah.text)
            }));

            let matchCount = 0;

            // 1. STATE TRACKING: Keep track of where we are in the Surah.
            // We start at Ayah index 0. We will never search before this index.
            let currentAyahIndex = 0;

            // 2. WINDOW CONFIG: How many Ayahs ahead should we look?
            // 5 is usually safe to handle pauses or skipped segments.
            const LOOKAHEAD_WINDOW = 5;

            for (const segment of segments) {
                const heardText = segment.text || '';
                // Skip very short noise segments (less than 3 chars)
                if (heardText.trim().length < 3) continue;

                const normalizedSegment = normalizeArabic(heardText);

                // Variables to track the best match found within our specific WINDOW
                let bestMatch = null;
                let bestScore = 0; // Higher is better
                let bestMatchIndex = -1;

                // Constraint: Only search from currentAyahIndex up to (current + Window)
                // This ensures O(1) performance instead of O(N) per segment.
                const searchEnd = Math.min(currentAyahIndex + LOOKAHEAD_WINDOW, normalizedSurah.length);

                for (let i = currentAyahIndex; i < searchEnd; i++) {
                    const ayahNorm = normalizedSurah[i].normalized;

                    // Strategy A: Exact Containment (Fastest & Most Accurate)
                    if (ayahNorm.includes(normalizedSegment)) {
                        // Calculate score: Base 50 + Boost based on how much of the Ayah is covered
                        const score = (normalizedSegment.length / ayahNorm.length) * 100 + 50;
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = surahText[i];
                            bestMatchIndex = i;
                        }
                        // If we find an exact match inside this Ayah, we prefer it over fuzzy matches
                        continue;
                    }

                    // Strategy B: Fuzzy Match (Levenshtein)
                    // Optimization: Skip expensive calculation if lengths are wildly different
                    const lenDiff = Math.abs(normalizedSegment.length - ayahNorm.length);
                    if (lenDiff < Math.max(normalizedSegment.length, ayahNorm.length) * 0.6) {
                        const distance = levenshtein(normalizedSegment, ayahNorm);
                        const maxLength = Math.max(normalizedSegment.length, ayahNorm.length);
                        const similarity = ((maxLength - distance) / maxLength) * 100;

                        if (similarity > 60 && similarity > bestScore) {
                            bestScore = similarity;
                            bestMatch = surahText[i];
                            bestMatchIndex = i;
                        }
                    }

                    // Strategy C: Word Overlap (Backup for short segments or heavy noise)
                    if (normalizedSegment.length < ayahNorm.length * 0.5) {
                        const segWords = normalizedSegment.split(' ');
                        const ayahWords = ayahNorm.split(' ');
                        let wordMatches = 0;
                        for (const w of segWords) {
                            // Check words longer than 2 chars to avoid matching 'in', 'al', etc.
                            if (w.length > 2 && ayahWords.includes(w)) wordMatches++;
                        }
                        const wordScore = (wordMatches / segWords.length) * 100;

                        // Use a stricter threshold (75%) for this heuristic
                        if (wordScore > 75 && wordScore > bestScore) {
                            bestScore = wordScore;
                            bestMatch = surahText[i];
                            bestMatchIndex = i;
                        }
                    }
                }

                if (bestMatch) {
                    matchCount++;

                    // CRITICAL LOGIC: Update the tracker.
                    // If we matched Ayah 5, the next search will start at Ayah 5.
                    // It will NEVER search Ayah 1-4 again.
                    currentAyahIndex = bestMatchIndex;

                    timeline.push({
                        surah: bestMatch.surah,
                        ayah: bestMatch.ayah,
                        text: bestMatch.text,
                        start: segment.start || 0,
                        end: segment.end || 0
                    });
                }
            }

            console.log("[TIMELINE] Built timeline with", timeline.length, "entries (matched", matchCount, "segments)");

            // --- Merging Phase ---
            // Merge consecutive segments that belong to the same Ayah
            const merged = {};
            for (const entry of timeline) {
                const key = `${entry.surah}-${entry.ayah}`;
                if (!merged[key]) {
                    merged[key] = {
                        surah: entry.surah,
                        ayah: entry.ayah,
                        text: entry.text,
                        start: entry.start,
                        end: entry.end
                    };
                } else {
                    // Extend the range to include this new segment
                    merged[key].start = Math.min(merged[key].start, entry.start);
                    merged[key].end = Math.max(merged[key].end, entry.end);
                }
            }

            const mergedTimeline = Object.values(merged);
            mergedTimeline.sort((a, b) => a.start - b.start);
            console.log("[TIMELINE] After merging duplicates:", mergedTimeline.length, "unique ayahs");

            // --- Gap Filling Phase ---
            // Ensure highlighted regions flow smoothly into each other
            for (let i = 0; i < mergedTimeline.length - 1; i++) {
                // If there is a gap between this ayah and the next, bridge it
                // so the highlight doesn't disappear during the pause.
                if (mergedTimeline[i].end < mergedTimeline[i + 1].start) {
                    mergedTimeline[i].end = mergedTimeline[i + 1].start;
                }
            }

            // Add a small buffer to the final ayah so it doesn't cut off instantly
            if (mergedTimeline.length > 0) {
                mergedTimeline[mergedTimeline.length - 1].end += 1.5;
            }

            return mergedTimeline;
        }

        async function loadHistory() {
            const select = document.getElementById('historySelect');
            // Save current selection if any
            const currentSelection = select.value;

            select.innerHTML = '<option value="">Select a previous recitation...</option>';

            const map = new Map();

            // 1. Local IndexedDB (Highest Priority)
            try {
                const localItems = await LocalDB.getAllRecitations();
                if (localItems) {
                    localItems.forEach(item => map.set(item.id, { ...item, source: 'local' }));
                }
            } catch (e) { console.warn("[HISTORY] LocalDB error", e); }

            // 2. Server History
            try {
                const response = await fetch('/history');
                if (response.ok) {
                    const serverItems = await response.json();
                    serverItems.forEach(item => {
                        // Only add if not already present from local DB (prefer local because it has blob)
                        if (!map.has(item.id)) {
                            map.set(item.id, { ...item, source: 'server' });
                        }
                    });
                }
            } catch (e) { console.warn("[HISTORY] Server history error", e); }

            const allItems = Array.from(map.values()).sort((a, b) => b.timestamp - a.timestamp);

            if (allItems.length === 0) {
                console.log("[HISTORY] No recitations found.");
                return;
            }

            allItems.forEach(item => {
                const option = document.createElement('option');
                option.value = item.id;
                let label = item.surah_name;
                if (item.surah_number) label = `${item.surah_number}. ${label}`;
                if (item.title) label += ` - ${item.title}`;

                if (item.source === 'local') {
                    label += ' (Downloaded)';
                }
                option.textContent = label;
                select.appendChild(option);
            });

            // Restore selection if it still exists
            if (currentSelection && map.has(currentSelection)) {
                select.value = currentSelection;
            }
        }

        // Deprecated: Old localStorage method removed in favor of IndexedDB
        // function saveToHistory(data) { ... }

        async function loadFromHistory() {
            const select = document.getElementById('historySelect');
            const videoId = select.value;
            if (!videoId) return;

            // Update URL input for reference
            document.getElementById('urlInput').value = `https://www.youtube.com/watch?v=${videoId}`;

            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = true;
            processBtn.textContent = "Loading...";

            try {
                // 1. Try Local IndexedDB first (Best for offline)
                try {
                    const localData = await LocalDB.getRecitation(videoId);
                    if (localData && localData.audioBlob) {
                        console.log("[CACHE] Loaded from IndexedDB!");

                        // Create a Blob URL for the audio
                        localData.audio_url = URL.createObjectURL(localData.audioBlob);

                        initializePlayer(localData);
                        processBtn.disabled = false;
                        processBtn.textContent = "Process";
                        return;
                    }
                } catch (e) {
                    console.warn("[CACHE] IndexedDB lookup failed:", e);
                }

                // 2. Try Browser Cache / Service Worker (File based)
                let response = await fetch(`/cache/${videoId}.json`);

                if (response.ok) {
                    console.log("[CACHE] Loaded from browser cache/server!");
                    const data = await response.json();
                    data.id = videoId;
                    // Use filename from JSON if available, else fallback
                    if (data.audio_filename) {
                        data.audio_url = `/cache/${data.audio_filename}`;
                    } else {
                        data.audio_url = `/cache/${videoId}.m4a`;
                    }

                    // If surah_text is missing, fetch it from the API
                    if (!data.surah_text || data.surah_text.length === 0) {
                        console.log("[CACHE] Surah text missing, fetching from API...");
                        const surahId = data.surah_id || data.surah_number;
                        if (surahId) {
                            data.surah_text = await fetchSurahText(surahId);
                            data.surah_number = surahId;
                        }
                    }

                    // If timeline is missing, build it
                    if ((!data.timeline || data.timeline.length === 0) && data.segments && data.surah_text) {
                        console.log("[CACHE] Building timeline from segments...");
                        data.timeline = buildTimeline(data.segments, data.surah_text);
                    }

                    // SAVE TO INDEXEDDB FOR NEXT TIME
                    // Fetch the audio as blob and save everything
                    fetch(data.audio_url)
                        .then(r => r.blob())
                        .then(blob => {
                            console.log("[CACHE] Upgrading to IndexedDB...");
                            LocalDB.saveRecitation(data, blob).then(() => {
                                console.log("[CACHE] Upgraded successfully");
                                loadHistory(); // Update UI to show (Downloaded)
                            });
                        })
                        .catch(e => console.warn("Failed to upgrade to IDB", e));

                    initializePlayer(data);
                } else {
                    // 3. Fallback: Fetch from Server API (Dynamic)
                    console.log("[CACHE] Not in static cache, fetching from API...");
                    response = await fetch(`/recitation/${videoId}`);
                    if (!response.ok) throw new Error("Failed to load recitation from server");

                    const data = await response.json();
                    initializePlayer(data);

                    // Attempt to save to cache
                    if (data.id) {
                        // Use audio_url which should be set correctly by now
                        let audioFetchUrl = data.audio_url || `/cache/${data.id}.m4a`;
                        fetch(audioFetchUrl)
                            .then(r => r.blob())
                            .then(blob => LocalDB.saveRecitation(data, blob))
                            .then(loadHistory);
                    }
                }
            } catch (e) {
                console.error(e);
                alert("Failed to load recitation. The file may not exist.");
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "Process";
            }
        }

        async function startProcess() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) { alert("Please enter a YouTube URL"); return; }

            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = true;
            processBtn.textContent = "Processing...";

            try {
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url })
                });

                if (!response.ok) throw new Error((await response.json()).detail || "Processing failed");
                const data = await response.json();

                // Initialize player first so user sees progress
                initializePlayer(data);

                // Background: Save to IndexedDB
                if (data.id && data.audio_url) {
                    console.log("[CACHE] Downloading audio for offline storage...");
                    fetch(data.audio_url)
                        .then(response => {
                            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
                            return response.blob();
                        })
                        .then(blob => {
                            if (blob.size < 1000) throw new Error(`Blob too small (${blob.size} bytes), likely error page.`);
                            console.log(`[CACHE] Saving to IndexedDB (${(blob.size / 1024 / 1024).toFixed(2)} MB)...`);
                            return LocalDB.saveRecitation(data, blob);
                        })
                        .then(() => {
                            console.log("[CACHE] Saved offline successfully.");
                            loadHistory(); // Refresh dropdown to show 'Downloaded'
                        })
                        .catch(err => console.error("[CACHE] Failed to save offline:", err));
                } else {
                    console.warn("[CACHE] No audio URL to cache.");
                }
            } catch (e) {
                alert("Error: " + e.message);
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "Process";
            }
        }

        function initializePlayer(data) {
            console.log("Initializing Player with data:", data);
            if (!data.surah_text || data.surah_text.length === 0) {
                console.warn("[PLAYER] Surah text is empty, text display will be unavailable");
            }

            if (!data.timeline || data.timeline.length === 0) {
                console.warn("[PLAYER] Timeline is empty! Syncing will not work.");
            } else {
                console.log("[PLAYER] Timeline loaded with", data.timeline.length, "entries");
                console.log("[PLAYER] First timeline entry:", data.timeline[0]);
            }

            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('surahTitle').textContent = `Surah ${data.surah_name}`;
            document.getElementById('surahDetails').textContent = `Surah #${data.surah_number} ‚Ä¢ ${data.title}`;
            audioPlayer.src = data.audio_url;
            audioPlayer.load();
            currentTimeline = data.timeline;
            renderQuranText(data.surah_text);
        }

        function renderQuranText(surahText) {
            const container = document.getElementById('quranContainer');
            container.innerHTML = '';

            const basmalaText = 'ÿ®Ÿêÿ≥ŸíŸÖŸê Ÿ±ŸÑŸÑŸéŸëŸáŸê Ÿ±ŸÑÿ±ŸéŸëÿ≠ŸíŸÖŸéŸ∞ŸÜŸê Ÿ±ŸÑÿ±ŸéŸëÿ≠ŸêŸäŸÖŸê';
            const cleanBasmala = 'ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ±ÿ≠ŸÖŸÜ ÿßŸÑÿ±ÿ≠ŸäŸÖ';

            // Helper to remove diacritics for comparison
            const normalize = (text) => text.replace(/[\u064B-\u065F\u0670]/g, '').replace(/[Ÿ±ÿ•ÿ£ÿ¢]/g, 'ÿß').replace(/ÿ©/g, 'Ÿá').replace(/Ÿâ/g, 'Ÿä');

            // Always render Basmala for all Surahs except Tawbah (9)
            // We get surah number from the data object passed to initializePlayer, 
            // but here we only have surahText. 
            // We can infer it or just check the text content.

            // Let's check the first ayah
            const firstAyah = surahText[0];
            let startIndex = 0;

            if (firstAyah) {
                const normText = normalize(firstAyah.text);
                const normBasmala = normalize(basmalaText);

                // Check if first ayah contains Basmala
                if (normText.includes(cleanBasmala) || normText.includes(normBasmala)) {
                    // It's in the text, so we render the header and strip it from the ayah
                    const basmalaDiv = document.createElement('div');
                    basmalaDiv.className = 'basmala';
                    basmalaDiv.textContent = basmalaText;
                    container.appendChild(basmalaDiv);

                    // Remove Basmala from the text
                    // We try to remove the exact string first, then fallback to loose removal if needed
                    // But usually if it's there, it's at the start.

                    // Simple approach: If it starts with Basmala, slice it. 
                    // Since we don't know the exact diacritics in the text, this is tricky.
                    // But we can try to find the end of the Basmala in the text.

                    // For now, let's assume if we matched it, we want to show the header.
                    // And we try to strip it. If we can't strip it cleanly, we might duplicate it?
                    // No, let's try to strip based on length if normalized matches start.

                    let textToShow = firstAyah.text;
                    if (normText.startsWith(cleanBasmala) || normText.startsWith(normBasmala)) {
                        // It is at the start. 
                        // We need to remove the corresponding characters from the original text.
                        // This is hard because diacritics change length.

                        // Hack: Split by space and remove first 4 words? 
                        // Basmala is 4 words: Bism Allah Ar-Rahman Ar-Rahim
                        const words = firstAyah.text.split(' ');
                        if (words.length >= 4) {
                            // Reconstruct without first 4 words
                            textToShow = words.slice(4).join(' ');
                        }
                    }

                    if (textToShow.trim().length > 0) {
                        const span = document.createElement('span');
                        span.id = `ayah-${firstAyah.ayah}`;
                        span.className = 'ayah-span';
                        span.textContent = textToShow;
                        span.onclick = () => seekToAyah(firstAyah.ayah);

                        const marker = document.createElement('span');
                        marker.className = 'ayah-marker';
                        marker.innerHTML = `€ù<span class="ayah-number">${firstAyah.ayah}</span>`;

                        container.appendChild(span);
                        container.appendChild(marker);
                        container.appendChild(document.createTextNode(' '));
                    }
                    startIndex = 1;
                } else {
                    // Basmala NOT in text. 
                    // We should still render the header if it's not Surah 9 (Tawbah).
                    // Since we don't have surah number here easily without changing function signature,
                    // let's assume we always want Basmala header unless it's Surah 1 (where it IS the first ayah).

                    // Actually, for Surah 1, Basmala IS Ayah 1. So it was caught above.
                    // For others, it's usually not in text.
                    // So we should add the header here.

                    // Exception: Surah 9.
                    // We can check if surahText[0].surah === 9
                    if (firstAyah.surah !== 9) {
                        const basmalaDiv = document.createElement('div');
                        basmalaDiv.className = 'basmala';
                        basmalaDiv.textContent = basmalaText;
                        container.appendChild(basmalaDiv);
                    }

                    // Render first ayah normally
                    startIndex = 0;
                }
            }

            for (let i = startIndex; i < surahText.length; i++) {
                const ayah = surahText[i];
                const span = document.createElement('span');
                span.id = `ayah-${ayah.ayah}`;
                span.className = 'ayah-span';
                span.textContent = ayah.text;
                span.onclick = () => seekToAyah(ayah.ayah);

                const marker = document.createElement('span');
                marker.className = 'ayah-marker';
                marker.innerHTML = `€ù<span class="ayah-number">${ayah.ayah}</span>`;

                container.appendChild(span);
                container.appendChild(marker);
                container.appendChild(document.createTextNode(' '));
            }
        }


        function seekToAyah(ayahNumber) {
            const match = currentTimeline.find(t => t.ayah === ayahNumber);
            if (match) {
                audioPlayer.currentTime = match.start;
                audioPlayer.play();
            }
        }

        audioPlayer.ontimeupdate = () => {
            const time = audioPlayer.currentTime;
            const activeSegment = currentTimeline.find(t => time >= t.start && time <= t.end);

            // Debug log (throttled to every second roughly)
            if (Math.floor(time) % 5 === 0 && !audioPlayer.paused) {
                console.log(`[PLAYBACK] Time: ${time.toFixed(2)}s, Active Segment:`, activeSegment ? `Ayah ${activeSegment.ayah}` : "None");
            }

            document.querySelectorAll('.active-ayah').forEach(el => el.classList.remove('active-ayah'));

            const btn = document.getElementById('scrollToCurrentBtn');

            if (activeSegment) {
                const el = document.getElementById(`ayah-${activeSegment.ayah}`);
                if (el) {
                    el.classList.add('active-ayah');
                    // Show button if we have an active ayah
                    btn.classList.add('visible');

                    // --- Auto-Scroll Trigger ---
                    if (!isUserInteracting) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    // --- REPEAT LOGIC ---
                    handleRepeatLogic(activeSegment, time);

                } else {
                    console.warn(`[PLAYBACK] Active segment found for Ayah ${activeSegment.ayah}, but DOM element #ayah-${activeSegment.ayah} not found!`);
                }
            }
        };

        function handleRepeatLogic(segment, time) {
            // Simple logic: if loopSurah is true, we want the player to loop.
            // Check if native loop is set correctly.
            if (audioPlayer.loop !== loopSurah) {
                audioPlayer.loop = loopSurah;
            }
        }

        function scrollToCurrent() {
            const activeEl = document.querySelector('.active-ayah');
            if (activeEl) {
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function changeFont() {
            const font = document.getElementById('fontSelect').value;
            // Add a style tag to override dynamically if needed, but variable is cleaner we already use var(--quran-font)
            document.documentElement.style.setProperty('--quran-font', font);
            localStorage.setItem('quranFont', font);
        }

        function changeFontSize() {
            const size = document.getElementById('fontSizeSlider').value;
            document.documentElement.style.setProperty('--quran-font-size', `${size}rem`);
            document.getElementById('fontSizeValue').textContent = `${size}rem`;
            localStorage.setItem('quranFontSize', size);
        }

        // --- Settings Modal Logic ---
        function openSettings() {
            document.getElementById('settingsModal').classList.remove('hidden');
            renderDownloadsList();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        async function renderDownloadsList() {
            const list = document.getElementById('downloadsList');
            list.innerHTML = '<p class="text-gray-500 text-sm italic">Loading...</p>';

            try {
                const downloads = await LocalDB.getAllRecitations();
                if (!downloads || downloads.length === 0) {
                    list.innerHTML = '<p class="text-gray-500 text-sm italic">No downloads found on this device.</p>';
                    return;
                }

                list.innerHTML = '';
                downloads.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center p-3 bg-gray-50 rounded-lg border border-gray-100';

                    const info = document.createElement('div');
                    info.className = 'flex-1 min-w-0 mr-3';

                    const title = document.createElement('h5');
                    title.className = 'text-sm font-medium text-gray-800 truncate';
                    title.textContent = `${item.surah_name} (${item.surah_number})`;

                    const subtitle = document.createElement('p');
                    subtitle.className = 'text-xs text-gray-500 truncate';
                    subtitle.textContent = item.title;

                    const size = document.createElement('p');
                    size.className = 'text-xs text-gray-400 mt-1';
                    // Estimate size if blob exists
                    const mb = item.audioBlob ? (item.audioBlob.size / 1024 / 1024).toFixed(1) : "?";
                    size.textContent = `${mb} MB ‚Ä¢ ${new Date(item.timestamp).toLocaleDateString()}`;

                    info.appendChild(title);
                    info.appendChild(subtitle);
                    info.appendChild(size);

                    const btn = document.createElement('button');
                    btn.className = 'text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-50 transition';
                    btn.title = "Delete Download";
                    btn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    `;
                    btn.onclick = () => deleteDownload(item.id);

                    div.appendChild(info);
                    div.appendChild(btn);
                    list.appendChild(div);
                });
            } catch (e) {
                list.innerHTML = `<p class="text-red-500 text-sm">Error loading downloads: ${e.message}</p>`;
            }
        }

        async function deleteDownload(id) {
            if (!confirm("Are you sure you want to delete this downloaded recitation?")) return;

            try {
                await LocalDB.deleteRecitation(id);
                // Refresh list
                renderDownloadsList();
                // Refresh main history dropdown
                loadHistory();
            } catch (e) {
                alert("Failed to delete: " + e.message);
            }
        }

        // --- Update Notification Logic ---
        function showUpdateToast() {
            const toast = document.getElementById('updateToast');
            toast.classList.remove('hidden');
            setTimeout(() => {
                toast.classList.remove('translate-y-20', 'opacity-0');
            }, 10);
        }

        function dismissToast() {
            const toast = document.getElementById('updateToast');
            toast.classList.add('translate-y-20', 'opacity-0');
            setTimeout(() => {
                toast.classList.add('hidden');
            }, 500);
        }

        // Listen for new service worker taking over
        let refreshing = false;
        // Track if we were controlled at load time (to differentiate first install vs update)
        const isControlled = Boolean(navigator.serviceWorker.controller);

        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (refreshing) return;
            // Only show toast if we were already controlled (i.e., this is an update, not a fresh install)
            if (isControlled) {
                showUpdateToast();
            }
        });

        window.onload = () => {
            // Init settings
            const savedFont = localStorage.getItem('quranFont');
            if (savedFont) {
                document.getElementById('fontSelect').value = savedFont;
                document.documentElement.style.setProperty('--quran-font', savedFont);
            }
            const savedSize = localStorage.getItem('quranFontSize');
            if (savedSize) {
                document.getElementById('fontSizeSlider').value = savedSize;
                document.getElementById('fontSizeValue').textContent = `${savedSize}rem`;
                document.documentElement.style.setProperty('--quran-font-size', `${savedSize}rem`);
            }

            loadHistory();

            // Request Persistent Storage
            if (navigator.storage && navigator.storage.persist) {
                navigator.storage.persist().then(granted => {
                    console.log(granted ? "[STORAGE] Persistent storage granted" : "[STORAGE] Persistent storage NOT granted");
                });
            }

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(reg => {
                        console.log('Service Worker Registered', reg);

                        // Check for waiting worker on load
                        if (reg.waiting) {
                            showUpdateToast();
                        }
                    })
                    .catch(err => console.log('Service Worker Failed', err));
            }
        };
        // --- Read Mode Logic ---
        let surahListCache = null;

        function switchMode(mode) {
            const tabYoutube = document.getElementById('tab-youtube');
            const tabRead = document.getElementById('tab-read');
            const controlsYoutube = document.getElementById('controls-youtube');
            const controlsRead = document.getElementById('controls-read');
            const resultsArea = document.getElementById('resultsArea');
            const stickyPlayer = document.getElementById('sticky-player');

            if (mode === 'youtube') {
                // Activate YouTube Tab
                tabYoutube.classList.add('text-emerald-400', 'border-emerald-400');
                tabYoutube.classList.remove('text-slate-400', 'border-transparent');

                tabRead.classList.add('text-slate-400', 'border-transparent');
                tabRead.classList.remove('text-emerald-400', 'border-emerald-400');

                // Show YouTube Controls
                controlsYoutube.classList.remove('hidden');
                controlsRead.classList.add('hidden');

                // If we were in read mode, we might want to hide results until processed
                // But if we have a previous youtube result, we could keep it. 
                // For simplicity, let's clear results if switching modes to avoid confusion
                resultsArea.classList.add('hidden');
                stickyPlayer.classList.remove('hidden'); // Show player for YouTube
            } else {
                // Activate Read Tab
                tabRead.classList.add('text-emerald-400', 'border-emerald-400');
                tabRead.classList.remove('text-slate-400', 'border-transparent');

                tabYoutube.classList.add('text-slate-400', 'border-transparent');
                tabYoutube.classList.remove('text-emerald-400', 'border-emerald-400');

                // Show Read Controls
                controlsRead.classList.remove('hidden');
                controlsYoutube.classList.add('hidden');

                // Fetch Surahs if not loaded
                if (!surahListCache) {
                    fetchSurahs();
                }

                // Prepare Setup
                resultsArea.classList.add('hidden');
                stickyPlayer.classList.add('hidden'); // Hide player for Read Mode
            }
        }

        async function fetchSurahs() {
            const select = document.getElementById('surahSelect');
            select.disabled = true;
            select.innerHTML = '<option>Loading Surahs...</option>';

            try {
                // Use our new backend endpoint
                const response = await fetch(`${API_BASE_URL}/surahs`);
                if (!response.ok) throw new Error('Failed to fetch surahs');

                const surahs = await response.json();
                surahListCache = surahs;

                // Populate Dropdown
                select.innerHTML = '<option value="">Choose a Surah...</option>';
                surahs.forEach(surah => {
                    const option = document.createElement('option');
                    option.value = surah.number;
                    option.textContent = `${surah.number}. ${surah.name} (${surah.englishNameTranslation})`;
                    select.appendChild(option);
                });
            } catch (e) {
                console.error("Error loading surahs:", e);
                select.innerHTML = '<option>Error loading list</option>';
            } finally {
                select.disabled = false;
            }
        }

        async function loadSelectedSurah() {
            const surahNumber = document.getElementById('surahSelect').value;
            if (!surahNumber) return;

            // Show loading state
            const resultsArea = document.getElementById('resultsArea');
            const quranContainer = document.getElementById('quranContainer');
            const surahTitle = document.getElementById('surahTitle');
            const surahDetails = document.getElementById('surahDetails');

            resultsArea.classList.remove('hidden');
            quranContainer.innerHTML = '<div class="text-center p-10"><div class="animate-spin h-10 w-10 border-4 border-emerald-500 rounded-full border-t-transparent mx-auto"></div></div>';

            // Set basics from cache
            const surahInfo = surahListCache.find(s => s.number == surahNumber);
            if (surahInfo) {
                surahTitle.textContent = surahInfo.name;
                surahDetails.textContent = `${surahInfo.revelationType} ‚Ä¢ ${surahInfo.numberOfAyahs} Ayahs`;
            }

            try {
                // Fetch text from backend
                const response = await fetch(`${API_BASE_URL}/surah/${surahNumber}`);
                if (!response.ok) throw new Error('Failed to fetch text');

                const ayahs = await response.json();
                renderSimpleSurah(ayahs, surahNumber);

            } catch (e) {
                console.error("Error fetching text:", e);
                quranContainer.innerHTML = '<p class="text-center text-red-500">Failed to load Surah text.</p>';
            }
        }

        function renderSimpleSurah(ayahs, surahNumber) {
            const container = document.getElementById('quranContainer');
            container.innerHTML = ''; // Clear

            let ayahsToRender = ayahs;

            // Handle Basmala Logic
            if (surahNumber == 1) {
                // For Surah 1, the first ayah IS the Basmala. 
                // We extract it and render it centered.
                if (ayahs.length > 0) {
                    const basmalaText = ayahs[0].text;
                    const basmalaDiv = document.createElement('div');
                    basmalaDiv.className = 'basmala';
                    basmalaDiv.textContent = basmalaText;
                    container.appendChild(basmalaDiv);

                    // Remove first ayah from standard flow
                    ayahsToRender = ayahs.slice(1);
                }
            } else if (surahNumber != 9) {
                // For all other Surahs (except 9), we add the standard Basmala header
                const basmalaDiv = document.createElement('div');
                basmalaDiv.className = 'basmala';
                basmalaDiv.textContent = "ÿ®Ÿêÿ≥ŸíŸÖŸê Ÿ±ŸÑŸÑŸëŸéŸáŸê Ÿ±ŸÑÿ±ŸëŸéÿ≠ŸíŸÖŸéŸÄŸ∞ŸÜŸê Ÿ±ŸÑÿ±ŸëŸéÿ≠ŸêŸäŸÖŸê";
                container.appendChild(basmalaDiv);
            }

            // Create wrapper
            const wrapper = document.createElement('div');
            // Using standard quran-text class but ensuring line-height is good
            wrapper.className = 'leading-loose text-justify';

            ayahsToRender.forEach(item => {
                const span = document.createElement('span');
                span.className = 'ayah-span hover:bg-emerald-50 cursor-default'; // Simplify interaction
                span.textContent = item.text;

                // Add ayah marker
                const marker = document.createElement('span');
                marker.className = 'ayah-marker';
                marker.innerHTML = `€ù <span class="ayah-number">${item.ayah}</span>`;

                span.appendChild(marker);
                wrapper.appendChild(span);

                // Add generic space
                wrapper.appendChild(document.createTextNode(' '));
            });

            container.appendChild(wrapper);
        }

        // --- Existing Code Ends ---
    </script>
</body>

</html>